{"version":3,"file":"js/324.db78672b.js","mappings":"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","sources":["webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/HighDynamicRange/panoramaToCubemap.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/HighDynamicRange/hdr.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Materials/Textures/Loaders/hdrTextureLoader.js"],"sourcesContent":["import { Vector3 } from \"../../Maths/math.vector.js\";\n\n/**\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\n */\nexport class PanoramaToCubeMapTools {\n    /**\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\n     *\n     * @param float32Array The source data.\n     * @param inputWidth The width of the input panorama.\n     * @param inputHeight The height of the input panorama.\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n     * @param supersample enable supersampling the cubemap\n     * @returns The cubemap data\n     */\n    static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size, supersample = false) {\n        if (!float32Array) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\n        }\n        if (float32Array.length != inputWidth * inputHeight * 3) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\n        }\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\n        return {\n            front: textureFront,\n            back: textureBack,\n            left: textureLeft,\n            right: textureRight,\n            up: textureUp,\n            down: textureDown,\n            size: size,\n            type: 1,\n            format: 4,\n            gammaSpace: false,\n        };\n    }\n    static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight, supersample = false) {\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n        const textureArray = new Float32Array(buffer);\n        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\n        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\n        const sampleFactor = 1 / samples;\n        const sampleFactorSqr = sampleFactor * sampleFactor;\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\n        const dy = 1 / texSize;\n        let fy = 0;\n        for (let y = 0; y < texSize; y++) {\n            for (let sy = 0; sy < samples; sy++) {\n                let xv1 = faceData[0];\n                let xv2 = faceData[2];\n                for (let x = 0; x < texSize; x++) {\n                    for (let sx = 0; sx < samples; sx++) {\n                        const v = xv2.subtract(xv1).scale(fy).add(xv1);\n                        v.normalize();\n                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\n                        // 3 channels per pixels\n                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\n                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\n                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\n                        xv1 = xv1.add(rotDX1);\n                        xv2 = xv2.add(rotDX2);\n                    }\n                }\n                fy += dy * sampleFactor;\n            }\n        }\n        return textureArray;\n    }\n    static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {\n        let theta = Math.atan2(vDir.z, vDir.x);\n        const phi = Math.acos(vDir.y);\n        while (theta < -Math.PI) {\n            theta += 2 * Math.PI;\n        }\n        while (theta > Math.PI) {\n            theta -= 2 * Math.PI;\n        }\n        let dx = theta / Math.PI;\n        const dy = phi / Math.PI;\n        // recenter.\n        dx = dx * 0.5 + 0.5;\n        let px = Math.round(dx * inputWidth);\n        if (px < 0) {\n            px = 0;\n        }\n        else if (px >= inputWidth) {\n            px = inputWidth - 1;\n        }\n        let py = Math.round(dy * inputHeight);\n        if (py < 0) {\n            py = 0;\n        }\n        else if (py >= inputHeight) {\n            py = inputHeight - 1;\n        }\n        const inputY = inputHeight - py - 1;\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n        return {\n            r: r,\n            g: g,\n            b: b,\n        };\n    }\n}\nPanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\n//# sourceMappingURL=panoramaToCubemap.js.map","import { PanoramaToCubeMapTools } from \"./panoramaToCubemap.js\";\n/* This groups tools to convert HDR texture to native colors array. */\nfunction ldexp(mantissa, exponent) {\n    if (exponent > 1023) {\n        return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n    if (exponent < -1074) {\n        return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n    return mantissa * Math.pow(2, exponent);\n}\nfunction rgbe2float(float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n        /*nonzero pixel*/\n        exponent = ldexp(1.0, exponent - (128 + 8));\n        float32array[index + 0] = red * exponent;\n        float32array[index + 1] = green * exponent;\n        float32array[index + 2] = blue * exponent;\n    }\n    else {\n        float32array[index + 0] = 0;\n        float32array[index + 1] = 0;\n        float32array[index + 2] = 0;\n    }\n}\nfunction readStringLine(uint8array, startIndex) {\n    let line = \"\";\n    let character = \"\";\n    for (let i = startIndex; i < uint8array.length - startIndex; i++) {\n        character = String.fromCharCode(uint8array[i]);\n        if (character == \"\\n\") {\n            break;\n        }\n        line += character;\n    }\n    return line;\n}\n/**\n * Reads header information from an RGBE texture stored in a native array.\n * More information on this format are available here:\n * https://en.wikipedia.org/wiki/RGBE_image_format\n *\n * @param uint8array The binary file stored in  native array.\n * @returns The header information.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RGBE_ReadHeader(uint8array) {\n    let height = 0;\n    let width = 0;\n    let line = readStringLine(uint8array, 0);\n    if (line[0] != \"#\" || line[1] != \"?\") {\n        // eslint-disable-next-line no-throw-literal\n        throw \"Bad HDR Format.\";\n    }\n    let endOfHeader = false;\n    let findFormat = false;\n    let lineIndex = 0;\n    do {\n        lineIndex += line.length + 1;\n        line = readStringLine(uint8array, lineIndex);\n        if (line == \"FORMAT=32-bit_rle_rgbe\") {\n            findFormat = true;\n        }\n        else if (line.length == 0) {\n            endOfHeader = true;\n        }\n    } while (!endOfHeader);\n    if (!findFormat) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n    lineIndex += line.length + 1;\n    line = readStringLine(uint8array, lineIndex);\n    const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\n    const match = sizeRegexp.exec(line);\n    // TODO. Support +Y and -X if needed.\n    if (!match || match.length < 3) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, no size\";\n    }\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n    if (width < 8 || width > 0x7fff) {\n        // eslint-disable-next-line no-throw-literal\n        throw \"HDR Bad header format, unsupported size\";\n    }\n    lineIndex += line.length + 1;\n    return {\n        height: height,\n        width: width,\n        dataPosition: lineIndex,\n    };\n}\n/**\n * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n * This RGBE texture needs to store the information as a panorama.\n *\n * More information on this format are available here:\n * https://en.wikipedia.org/wiki/RGBE_image_format\n *\n * @param buffer The binary file stored in an array buffer.\n * @param size The expected size of the extracted cubemap.\n * @param supersample enable supersampling the cubemap (default: false)\n * @returns The Cube Map information.\n */\nexport function GetCubeMapTextureData(buffer, size, supersample = false) {\n    const uint8array = new Uint8Array(buffer);\n    const hdrInfo = RGBE_ReadHeader(uint8array);\n    const data = RGBE_ReadPixels(uint8array, hdrInfo);\n    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\n    return cubeMapData;\n}\n/**\n * Returns the pixels data extracted from an RGBE texture.\n * This pixels will be stored left to right up to down in the R G B order in one array.\n *\n * More information on this format are available here:\n * https://en.wikipedia.org/wiki/RGBE_image_format\n *\n * @param uint8array The binary file stored in an array buffer.\n * @param hdrInfo The header information of the file.\n * @returns The pixels data in RGB right to left up to down order.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RGBE_ReadPixels(uint8array, hdrInfo) {\n    return readRGBEPixelsRLE(uint8array, hdrInfo);\n}\nfunction readRGBEPixelsRLE(uint8array, hdrInfo) {\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, count;\n    let dataIndex = hdrInfo.dataPosition;\n    let index = 0, endIndex = 0, i = 0;\n    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n    const scanLineArray = new Uint8Array(scanLineArrayBuffer);\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n        if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n            return readRGBEPixelsNotRLE(uint8array, hdrInfo);\n        }\n        if (((c << 8) | d) != scanline_width) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"HDR Bad header format, wrong scan line width\";\n        }\n        index = 0;\n        // read each of the four channels for the scanline into the buffer\n        for (i = 0; i < 4; i++) {\n            endIndex = (i + 1) * scanline_width;\n            while (index < endIndex) {\n                a = uint8array[dataIndex++];\n                b = uint8array[dataIndex++];\n                if (a > 128) {\n                    // a run of the same value\n                    count = a - 128;\n                    if (count == 0 || count > endIndex - index) {\n                        // eslint-disable-next-line no-throw-literal\n                        throw \"HDR Bad Format, bad scanline data (run)\";\n                    }\n                    while (count-- > 0) {\n                        scanLineArray[index++] = b;\n                    }\n                }\n                else {\n                    // a non-run\n                    count = a;\n                    if (count == 0 || count > endIndex - index) {\n                        // eslint-disable-next-line no-throw-literal\n                        throw \"HDR Bad Format, bad scanline data (non-run)\";\n                    }\n                    scanLineArray[index++] = b;\n                    if (--count > 0) {\n                        for (let j = 0; j < count; j++) {\n                            scanLineArray[index++] = uint8array[dataIndex++];\n                        }\n                    }\n                }\n            }\n        }\n        // now convert data from buffer into floats\n        for (i = 0; i < scanline_width; i++) {\n            a = scanLineArray[i];\n            b = scanLineArray[i + scanline_width];\n            c = scanLineArray[i + 2 * scanline_width];\n            d = scanLineArray[i + 3 * scanline_width];\n            rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n        }\n        num_scanlines--;\n    }\n    return resultArray;\n}\nfunction readRGBEPixelsNotRLE(uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, i;\n    let dataIndex = hdrInfo.dataPosition;\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n        for (i = 0; i < hdrInfo.width; i++) {\n            a = uint8array[dataIndex++];\n            b = uint8array[dataIndex++];\n            c = uint8array[dataIndex++];\n            d = uint8array[dataIndex++];\n            rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n        }\n        num_scanlines--;\n    }\n    return resultArray;\n}\n/**\n * @deprecated Use functions separately\n */\nexport const HDRTools = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RGBE_ReadHeader,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    GetCubeMapTextureData,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    RGBE_ReadPixels,\n};\n//# sourceMappingURL=hdr.js.map","import { RGBE_ReadHeader, RGBE_ReadPixels } from \"../../../Misc/HighDynamicRange/hdr.js\";\n\n/**\n * Implementation of the HDR Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _HDRTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     */\n    loadCubeData() {\n        // eslint-disable-next-line no-throw-literal\n        throw \".env not supported in Cube.\";\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        const hdrInfo = RGBE_ReadHeader(uint8array);\n        const pixelsDataRGB32 = RGBE_ReadPixels(uint8array, hdrInfo);\n        const pixels = hdrInfo.width * hdrInfo.height;\n        const pixelsDataRGBA32 = new Float32Array(pixels * 4);\n        for (let i = 0; i < pixels; i += 1) {\n            pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];\n            pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];\n            pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];\n            pixelsDataRGBA32[i * 4 + 3] = 1;\n        }\n        callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {\n            const engine = texture.getEngine();\n            texture.type = 1;\n            texture.format = 5;\n            texture._gammaSpace = false;\n            engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);\n        });\n    }\n}\n//# sourceMappingURL=hdrTextureLoader.js.map"],"names":["PanoramaToCubeMapTools","static","float32Array","inputWidth","inputHeight","size","supersample","length","textureFront","this","CreateCubemapTexture","FACE_FRONT","textureBack","FACE_BACK","textureLeft","FACE_LEFT","textureRight","FACE_RIGHT","textureUp","FACE_UP","textureDown","FACE_DOWN","front","back","left","right","up","down","type","format","gammaSpace","texSize","faceData","buffer","ArrayBuffer","textureArray","Float32Array","samples","Math","max","round","sampleFactor","sampleFactorSqr","rotDX1","subtract","scale","rotDX2","dy","fy","y","sy","xv1","xv2","x","sx","v","add","normalize","color","CalcProjectionSpherical","r","g","b","vDir","theta","atan2","z","phi","acos","PI","dx","px","py","inputY","ldexp","mantissa","exponent","pow","rgbe2float","float32array","red","green","blue","index","readStringLine","uint8array","startIndex","line","character","i","String","fromCharCode","RGBE_ReadHeader","height","width","endOfHeader","findFormat","lineIndex","sizeRegexp","match","exec","parseInt","dataPosition","RGBE_ReadPixels","hdrInfo","readRGBEPixelsRLE","num_scanlines","scanline_width","a","c","d","count","dataIndex","endIndex","scanLineArrayBuffer","scanLineArray","Uint8Array","resultBuffer","resultArray","readRGBEPixelsNotRLE","j","_HDRTextureLoader","constructor","supportCascades","loadCubeData","loadData","data","texture","callback","byteOffset","byteLength","pixelsDataRGB32","pixels","pixelsDataRGBA32","generateMipMaps","engine","getEngine","_gammaSpace","_uploadDataToTextureDirectly"],"sourceRoot":""}