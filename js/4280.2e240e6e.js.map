{"version":3,"file":"js/4280.2e240e6e.js","mappings":"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","sources":["webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/khronosTextureContainer.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/workerPool.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Materials/Textures/ktx2decoderTypes.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/khronosTextureContainer2Worker.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/khronosTextureContainer2.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Materials/Textures/Loaders/ktxTextureLoader.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n */\nexport class KhronosTextureContainer {\n    /**\n     * Creates a new KhronosTextureContainer\n     * @param data contents of the KTX container file\n     * @param facesExpected should be either 1 or 6, based whether a cube texture or or\n     */\n    constructor(\n    /** contents of the KTX container file */\n    data, facesExpected) {\n        this.data = data;\n        /**\n         * If the container has been made invalid (eg. constructor failed to correctly load array buffer)\n         */\n        this.isInvalid = false;\n        if (!KhronosTextureContainer.IsValid(data)) {\n            this.isInvalid = true;\n            Logger.Error(\"texture missing KTX identifier\");\n            return;\n        }\n        // load the reset of the header in native 32 bit uint\n        const dataSize = Uint32Array.BYTES_PER_ELEMENT;\n        const headerDataView = new DataView(this.data.buffer, this.data.byteOffset + 12, 13 * dataSize);\n        const endianness = headerDataView.getUint32(0, true);\n        const littleEndian = endianness === 0x04030201;\n        this.glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures\n        this.glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures\n        this.glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures\n        this.glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n        this.glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n        this.pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n        this.pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n        this.pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n        this.numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays\n        this.numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6\n        this.numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures\n        this.bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data\n        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n        if (this.glType !== 0) {\n            Logger.Error(\"only compressed formats currently supported\");\n            this.isInvalid = true;\n            return;\n        }\n        else {\n            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n            this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n        }\n        if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n            Logger.Error(\"only 2D textures currently supported\");\n            this.isInvalid = true;\n            return;\n        }\n        if (this.numberOfArrayElements !== 0) {\n            Logger.Error(\"texture arrays not currently supported\");\n            this.isInvalid = true;\n            return;\n        }\n        if (this.numberOfFaces !== facesExpected) {\n            Logger.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\n            this.isInvalid = true;\n            return;\n        }\n        // we now have a completely validated file, so could use existence of loadType as success\n        // would need to make this more elaborate & adjust checks above to support more than one load type\n        this.loadType = KhronosTextureContainer.COMPRESSED_2D;\n    }\n    /**\n     * Uploads KTX content to a Babylon Texture.\n     * It is assumed that the texture has already been created & is currently bound\n     * @internal\n     */\n    uploadLevels(texture, loadMipmaps) {\n        switch (this.loadType) {\n            case KhronosTextureContainer.COMPRESSED_2D:\n                this._upload2DCompressedLevels(texture, loadMipmaps);\n                break;\n            case KhronosTextureContainer.TEX_2D:\n            case KhronosTextureContainer.COMPRESSED_3D:\n            case KhronosTextureContainer.TEX_3D:\n        }\n    }\n    _upload2DCompressedLevels(texture, loadMipmaps) {\n        // initialize width & height for level 1\n        let dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n        let width = this.pixelWidth;\n        let height = this.pixelHeight;\n        const mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n        for (let level = 0; level < mipmapCount; level++) {\n            const imageSize = new Int32Array(this.data.buffer, this.data.byteOffset + dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n            dataOffset += 4; //image data starts from next multiple of 4 offset. Each face refers to same imagesize field above.\n            for (let face = 0; face < this.numberOfFaces; face++) {\n                const byteArray = new Uint8Array(this.data.buffer, this.data.byteOffset + dataOffset, imageSize);\n                const engine = texture.getEngine();\n                engine._uploadCompressedDataToTextureDirectly(texture, texture.format, width, height, byteArray, face, level);\n                dataOffset += imageSize; // add size of the image for the next face/mipmap\n                dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\n            }\n            width = Math.max(1.0, width * 0.5);\n            height = Math.max(1.0, height * 0.5);\n        }\n    }\n    /**\n     * Checks if the given data starts with a KTX file identifier.\n     * @param data the data to check\n     * @returns true if the data is a KTX file or false otherwise\n     */\n    static IsValid(data) {\n        if (data.byteLength >= 12) {\n            // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\\r', '\\n', '\\x1A', '\\n'\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n            if (identifier[0] === 0xab &&\n                identifier[1] === 0x4b &&\n                identifier[2] === 0x54 &&\n                identifier[3] === 0x58 &&\n                identifier[4] === 0x20 &&\n                identifier[5] === 0x31 &&\n                identifier[6] === 0x31 &&\n                identifier[7] === 0xbb &&\n                identifier[8] === 0x0d &&\n                identifier[9] === 0x0a &&\n                identifier[10] === 0x1a &&\n                identifier[11] === 0x0a) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nKhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n// load types\nKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\nKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\nKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\nKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n//# sourceMappingURL=khronosTextureContainer.js.map","/**\n * Helper class to push actions to a pool of workers.\n */\nexport class WorkerPool {\n    /**\n     * Constructor\n     * @param workers Array of workers to use for actions\n     */\n    constructor(workers) {\n        this._pendingActions = new Array();\n        this._workerInfos = workers.map((worker) => ({\n            workerPromise: Promise.resolve(worker),\n            idle: true,\n        }));\n    }\n    /**\n     * Terminates all workers and clears any pending actions.\n     */\n    dispose() {\n        for (const workerInfo of this._workerInfos) {\n            workerInfo.workerPromise.then((worker) => {\n                worker.terminate();\n            });\n        }\n        this._workerInfos.length = 0;\n        this._pendingActions.length = 0;\n    }\n    /**\n     * Pushes an action to the worker pool. If all the workers are active, the action will be\n     * pended until a worker has completed its action.\n     * @param action The action to perform. Call onComplete when the action is complete.\n     */\n    push(action) {\n        if (!this._executeOnIdleWorker(action)) {\n            this._pendingActions.push(action);\n        }\n    }\n    _executeOnIdleWorker(action) {\n        for (const workerInfo of this._workerInfos) {\n            if (workerInfo.idle) {\n                this._execute(workerInfo, action);\n                return true;\n            }\n        }\n        return false;\n    }\n    _execute(workerInfo, action) {\n        workerInfo.idle = false;\n        workerInfo.workerPromise.then((worker) => {\n            action(worker, () => {\n                const nextAction = this._pendingActions.shift();\n                if (nextAction) {\n                    this._execute(workerInfo, nextAction);\n                }\n                else {\n                    workerInfo.idle = true;\n                }\n            });\n        });\n    }\n}\n/**\n * Similar to the WorkerPool class except it creates and destroys workers automatically with a maximum of `maxWorkers` workers.\n * Workers are terminated when it is idle for at least `idleTimeElapsedBeforeRelease` milliseconds.\n */\nexport class AutoReleaseWorkerPool extends WorkerPool {\n    constructor(maxWorkers, createWorkerAsync, options = AutoReleaseWorkerPool.DefaultOptions) {\n        super([]);\n        this._maxWorkers = maxWorkers;\n        this._createWorkerAsync = createWorkerAsync;\n        this._options = options;\n    }\n    push(action) {\n        if (!this._executeOnIdleWorker(action)) {\n            if (this._workerInfos.length < this._maxWorkers) {\n                const workerInfo = {\n                    workerPromise: this._createWorkerAsync(),\n                    idle: false,\n                };\n                this._workerInfos.push(workerInfo);\n                this._execute(workerInfo, action);\n            }\n            else {\n                this._pendingActions.push(action);\n            }\n        }\n    }\n    _execute(workerInfo, action) {\n        // Reset the idle timeout.\n        if (workerInfo.timeoutId) {\n            clearTimeout(workerInfo.timeoutId);\n            delete workerInfo.timeoutId;\n        }\n        super._execute(workerInfo, (worker, onComplete) => {\n            action(worker, () => {\n                onComplete();\n                if (workerInfo.idle) {\n                    // Schedule the worker to be terminated after the elapsed time.\n                    workerInfo.timeoutId = setTimeout(() => {\n                        workerInfo.workerPromise.then((worker) => {\n                            worker.terminate();\n                        });\n                        const indexOf = this._workerInfos.indexOf(workerInfo);\n                        if (indexOf !== -1) {\n                            this._workerInfos.splice(indexOf, 1);\n                        }\n                    }, this._options.idleTimeElapsedBeforeRelease);\n                }\n            });\n        });\n    }\n}\n/**\n * Default options for the constructor.\n * Override to change the defaults.\n */\nAutoReleaseWorkerPool.DefaultOptions = {\n    idleTimeElapsedBeforeRelease: 1000,\n};\n//# sourceMappingURL=workerPool.js.map","export var SourceTextureFormat;\n(function (SourceTextureFormat) {\n    SourceTextureFormat[SourceTextureFormat[\"ETC1S\"] = 0] = \"ETC1S\";\n    SourceTextureFormat[SourceTextureFormat[\"UASTC4x4\"] = 1] = \"UASTC4x4\";\n})(SourceTextureFormat || (SourceTextureFormat = {}));\nexport var TranscodeTarget;\n(function (TranscodeTarget) {\n    TranscodeTarget[TranscodeTarget[\"ASTC_4X4_RGBA\"] = 0] = \"ASTC_4X4_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"BC7_RGBA\"] = 1] = \"BC7_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"BC3_RGBA\"] = 2] = \"BC3_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"BC1_RGB\"] = 3] = \"BC1_RGB\";\n    TranscodeTarget[TranscodeTarget[\"PVRTC1_4_RGBA\"] = 4] = \"PVRTC1_4_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"PVRTC1_4_RGB\"] = 5] = \"PVRTC1_4_RGB\";\n    TranscodeTarget[TranscodeTarget[\"ETC2_RGBA\"] = 6] = \"ETC2_RGBA\";\n    TranscodeTarget[TranscodeTarget[\"ETC1_RGB\"] = 7] = \"ETC1_RGB\";\n    TranscodeTarget[TranscodeTarget[\"RGBA32\"] = 8] = \"RGBA32\";\n    TranscodeTarget[TranscodeTarget[\"R8\"] = 9] = \"R8\";\n    TranscodeTarget[TranscodeTarget[\"RG8\"] = 10] = \"RG8\";\n})(TranscodeTarget || (TranscodeTarget = {}));\nexport var EngineFormat;\n(function (EngineFormat) {\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_BPTC_UNORM_EXT\"] = 36492] = \"COMPRESSED_RGBA_BPTC_UNORM_EXT\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_ASTC_4X4_KHR\"] = 37808] = \"COMPRESSED_RGBA_ASTC_4X4_KHR\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB_S3TC_DXT1_EXT\"] = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_S3TC_DXT5_EXT\"] = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\"] = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\"] = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGBA8_ETC2_EAC\"] = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB8_ETC2\"] = 37492] = \"COMPRESSED_RGB8_ETC2\";\n    EngineFormat[EngineFormat[\"COMPRESSED_RGB_ETC1_WEBGL\"] = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\";\n    EngineFormat[EngineFormat[\"RGBA8Format\"] = 32856] = \"RGBA8Format\";\n    EngineFormat[EngineFormat[\"R8Format\"] = 33321] = \"R8Format\";\n    EngineFormat[EngineFormat[\"RG8Format\"] = 33323] = \"RG8Format\";\n})(EngineFormat || (EngineFormat = {}));\n//# sourceMappingURL=ktx2decoderTypes.js.map","export function applyConfig(urls, binariesAndModulesContainer) {\n    const KTX2DecoderModule = binariesAndModulesContainer?.jsDecoderModule || KTX2DECODER;\n    if (urls) {\n        if (urls.wasmUASTCToASTC) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmModuleURL = urls.wasmUASTCToASTC;\n        }\n        if (urls.wasmUASTCToBC7) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmModuleURL = urls.wasmUASTCToBC7;\n        }\n        if (urls.wasmUASTCToRGBA_UNORM) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmModuleURL = urls.wasmUASTCToRGBA_UNORM;\n        }\n        if (urls.wasmUASTCToRGBA_SRGB) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmModuleURL = urls.wasmUASTCToRGBA_SRGB;\n        }\n        if (urls.wasmUASTCToR8_UNORM) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmModuleURL = urls.wasmUASTCToR8_UNORM;\n        }\n        if (urls.wasmUASTCToRG8_UNORM) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmModuleURL = urls.wasmUASTCToRG8_UNORM;\n        }\n        if (urls.jsMSCTranscoder) {\n            KTX2DecoderModule.MSCTranscoder.JSModuleURL = urls.jsMSCTranscoder;\n        }\n        if (urls.wasmMSCTranscoder) {\n            KTX2DecoderModule.MSCTranscoder.WasmModuleURL = urls.wasmMSCTranscoder;\n        }\n        if (urls.wasmZSTDDecoder) {\n            KTX2DecoderModule.ZSTDDecoder.WasmModuleURL = urls.wasmZSTDDecoder;\n        }\n    }\n    if (binariesAndModulesContainer) {\n        if (binariesAndModulesContainer.wasmUASTCToASTC) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_ASTC.WasmBinary = binariesAndModulesContainer.wasmUASTCToASTC;\n        }\n        if (binariesAndModulesContainer.wasmUASTCToBC7) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_BC7.WasmBinary = binariesAndModulesContainer.wasmUASTCToBC7;\n        }\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_UNORM) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_UNORM;\n        }\n        if (binariesAndModulesContainer.wasmUASTCToRGBA_SRGB) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_RGBA_SRGB.WasmBinary = binariesAndModulesContainer.wasmUASTCToRGBA_SRGB;\n        }\n        if (binariesAndModulesContainer.wasmUASTCToR8_UNORM) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_R8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToR8_UNORM;\n        }\n        if (binariesAndModulesContainer.wasmUASTCToRG8_UNORM) {\n            KTX2DecoderModule.LiteTranscoder_UASTC_RG8_UNORM.WasmBinary = binariesAndModulesContainer.wasmUASTCToRG8_UNORM;\n        }\n        if (binariesAndModulesContainer.jsMSCTranscoder) {\n            KTX2DecoderModule.MSCTranscoder.JSModule = binariesAndModulesContainer.jsMSCTranscoder;\n        }\n        if (binariesAndModulesContainer.wasmMSCTranscoder) {\n            KTX2DecoderModule.MSCTranscoder.WasmBinary = binariesAndModulesContainer.wasmMSCTranscoder;\n        }\n        if (binariesAndModulesContainer.wasmZSTDDecoder) {\n            KTX2DecoderModule.ZSTDDecoder.WasmBinary = binariesAndModulesContainer.wasmZSTDDecoder;\n        }\n    }\n}\nexport function workerFunction(KTX2DecoderModule) {\n    if (typeof KTX2DecoderModule === \"undefined\" && typeof KTX2DECODER !== \"undefined\") {\n        KTX2DecoderModule = KTX2DECODER;\n    }\n    let ktx2Decoder;\n    onmessage = (event) => {\n        if (!event.data) {\n            return;\n        }\n        switch (event.data.action) {\n            case \"init\": {\n                const urls = event.data.urls;\n                if (urls) {\n                    if (urls.jsDecoderModule && typeof KTX2DecoderModule === \"undefined\") {\n                        importScripts(urls.jsDecoderModule);\n                        // assuming global namespace populated by the script (UMD pattern)\n                        KTX2DecoderModule = KTX2DECODER;\n                    }\n                    applyConfig(urls);\n                }\n                if (event.data.wasmBinaries) {\n                    applyConfig(undefined, { ...event.data.wasmBinaries, jsDecoderModule: KTX2DecoderModule });\n                }\n                ktx2Decoder = new KTX2DecoderModule.KTX2Decoder();\n                postMessage({ action: \"init\" });\n                break;\n            }\n            case \"setDefaultDecoderOptions\": {\n                KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = event.data.options;\n                break;\n            }\n            case \"decode\":\n                ktx2Decoder\n                    .decode(event.data.data, event.data.caps, event.data.options)\n                    .then((data) => {\n                    const buffers = [];\n                    for (let mip = 0; mip < data.mipmaps.length; ++mip) {\n                        const mipmap = data.mipmaps[mip];\n                        if (mipmap && mipmap.data) {\n                            buffers.push(mipmap.data.buffer);\n                        }\n                    }\n                    postMessage({ action: \"decoded\", success: true, decodedData: data }, buffers);\n                })\n                    .catch((reason) => {\n                    postMessage({ action: \"decoded\", success: false, msg: reason });\n                });\n                break;\n        }\n    };\n}\nexport function initializeWebWorker(worker, wasmBinaries, urls) {\n    return new Promise((resolve, reject) => {\n        const onError = (error) => {\n            worker.removeEventListener(\"error\", onError);\n            worker.removeEventListener(\"message\", onMessage);\n            reject(error);\n        };\n        const onMessage = (message) => {\n            if (message.data.action === \"init\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n            }\n        };\n        worker.addEventListener(\"error\", onError);\n        worker.addEventListener(\"message\", onMessage);\n        worker.postMessage({\n            action: \"init\",\n            urls,\n            wasmBinaries,\n        });\n    });\n}\n//# sourceMappingURL=khronosTextureContainer2Worker.js.map","\nimport { AutoReleaseWorkerPool } from \"./workerPool.js\";\nimport { Tools } from \"./tools.js\";\nimport { TranscodeTarget } from \"../Materials/Textures/ktx2decoderTypes.js\";\nimport { applyConfig, initializeWebWorker, workerFunction } from \"./khronosTextureContainer2Worker.js\";\n/**\n * Class that defines the default KTX2 decoder options.\n *\n * This class is useful for providing options to the KTX2 decoder to control how the source data is transcoded.\n */\nexport class DefaultKTX2DecoderOptions {\n    constructor() {\n        this._isDirty = true;\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = true;\n        this._ktx2DecoderOptions = {};\n    }\n    /**\n     * Gets the dirty flag\n     */\n    get isDirty() {\n        return this._isDirty;\n    }\n    /**\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and ASTC + BC7 are not available as a compressed transcoded format\n     */\n    get useRGBAIfASTCBC7NotAvailableWhenUASTC() {\n        return this._useRGBAIfASTCBC7NotAvailableWhenUASTC;\n    }\n    set useRGBAIfASTCBC7NotAvailableWhenUASTC(value) {\n        if (this._useRGBAIfASTCBC7NotAvailableWhenUASTC === value) {\n            return;\n        }\n        this._useRGBAIfASTCBC7NotAvailableWhenUASTC = value;\n        this._isDirty = true;\n    }\n    /**\n     * force a (uncompressed) RGBA transcoded format if transcoding a UASTC source format and only BC1 or BC3 are available as a compressed transcoded format.\n     * This property is true by default to favor speed over memory, because currently transcoding from UASTC to BC1/3 is slow because the transcoder transcodes\n     * to uncompressed and then recompresses the texture\n     */\n    get useRGBAIfOnlyBC1BC3AvailableWhenUASTC() {\n        return this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC;\n    }\n    set useRGBAIfOnlyBC1BC3AvailableWhenUASTC(value) {\n        if (this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC === value) {\n            return;\n        }\n        this._useRGBAIfOnlyBC1BC3AvailableWhenUASTC = value;\n        this._isDirty = true;\n    }\n    /**\n     * force to always use (uncompressed) RGBA for transcoded format\n     */\n    get forceRGBA() {\n        return this._forceRGBA;\n    }\n    set forceRGBA(value) {\n        if (this._forceRGBA === value) {\n            return;\n        }\n        this._forceRGBA = value;\n        this._isDirty = true;\n    }\n    /**\n     * force to always use (uncompressed) R8 for transcoded format\n     */\n    get forceR8() {\n        return this._forceR8;\n    }\n    set forceR8(value) {\n        if (this._forceR8 === value) {\n            return;\n        }\n        this._forceR8 = value;\n        this._isDirty = true;\n    }\n    /**\n     * force to always use (uncompressed) RG8 for transcoded format\n     */\n    get forceRG8() {\n        return this._forceRG8;\n    }\n    set forceRG8(value) {\n        if (this._forceRG8 === value) {\n            return;\n        }\n        this._forceRG8 = value;\n        this._isDirty = true;\n    }\n    /**\n     * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:\n     *      UniversalTranscoder_UASTC_ASTC\n     *      UniversalTranscoder_UASTC_BC7\n     *      UniversalTranscoder_UASTC_RGBA_UNORM\n     *      UniversalTranscoder_UASTC_RGBA_SRGB\n     *      UniversalTranscoder_UASTC_R8_UNORM\n     *      UniversalTranscoder_UASTC_RG8_UNORM\n     *      MSCTranscoder\n     */\n    get bypassTranscoders() {\n        return this._bypassTranscoders;\n    }\n    set bypassTranscoders(value) {\n        if (this._bypassTranscoders === value) {\n            return;\n        }\n        this._bypassTranscoders = value;\n        this._isDirty = true;\n    }\n    /** @internal */\n    _getKTX2DecoderOptions() {\n        if (!this._isDirty) {\n            return this._ktx2DecoderOptions;\n        }\n        this._isDirty = false;\n        const options = {\n            useRGBAIfASTCBC7NotAvailableWhenUASTC: this._useRGBAIfASTCBC7NotAvailableWhenUASTC,\n            forceRGBA: this._forceRGBA,\n            forceR8: this._forceR8,\n            forceRG8: this._forceRG8,\n            bypassTranscoders: this._bypassTranscoders,\n        };\n        if (this.useRGBAIfOnlyBC1BC3AvailableWhenUASTC) {\n            options.transcodeFormatDecisionTree = {\n                UASTC: {\n                    transcodeFormat: [TranscodeTarget.BC1_RGB, TranscodeTarget.BC3_RGBA],\n                    yes: {\n                        transcodeFormat: TranscodeTarget.RGBA32,\n                        engineFormat: 32856 /* EngineFormat.RGBA8Format */,\n                        roundToMultiple4: false,\n                    },\n                },\n            };\n        }\n        this._ktx2DecoderOptions = options;\n        return options;\n    }\n}\n/**\n * Class for loading KTX2 files\n */\nexport class KhronosTextureContainer2 {\n    static GetDefaultNumWorkers() {\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n            return 1;\n        }\n        // Use 50% of the available logical processors but capped at 4.\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n    }\n    static _Initialize(numWorkers) {\n        if (KhronosTextureContainer2._WorkerPoolPromise || KhronosTextureContainer2._DecoderModulePromise) {\n            return;\n        }\n        const urls = {\n            jsDecoderModule: Tools.GetBabylonScriptURL(this.URLConfig.jsDecoderModule, true),\n            wasmUASTCToASTC: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToASTC, true),\n            wasmUASTCToBC7: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToBC7, true),\n            wasmUASTCToRGBA_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_UNORM, true),\n            wasmUASTCToRGBA_SRGB: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRGBA_SRGB, true),\n            wasmUASTCToR8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToR8_UNORM, true),\n            wasmUASTCToRG8_UNORM: Tools.GetBabylonScriptURL(this.URLConfig.wasmUASTCToRG8_UNORM, true),\n            jsMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.jsMSCTranscoder, true),\n            wasmMSCTranscoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmMSCTranscoder, true),\n            wasmZSTDDecoder: Tools.GetBabylonScriptURL(this.URLConfig.wasmZSTDDecoder, true),\n        };\n        if (numWorkers && typeof Worker === \"function\" && typeof URL !== \"undefined\") {\n            KhronosTextureContainer2._WorkerPoolPromise = new Promise((resolve) => {\n                const workerContent = `${applyConfig}(${workerFunction})()`;\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\n                resolve(new AutoReleaseWorkerPool(numWorkers, () => initializeWebWorker(new Worker(workerBlobUrl), undefined, urls)));\n            });\n        }\n        else {\n            if (typeof KhronosTextureContainer2._KTX2DecoderModule === \"undefined\") {\n                KhronosTextureContainer2._DecoderModulePromise = Tools.LoadBabylonScriptAsync(urls.jsDecoderModule).then(() => {\n                    KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\n                    KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\n                    KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n                    applyConfig(urls, KhronosTextureContainer2._KTX2DecoderModule);\n                    return new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder();\n                });\n            }\n            else {\n                KhronosTextureContainer2._KTX2DecoderModule.MSCTranscoder.UseFromWorkerThread = false;\n                KhronosTextureContainer2._KTX2DecoderModule.WASMMemoryManager.LoadBinariesFromCurrentThread = true;\n                KhronosTextureContainer2._DecoderModulePromise = Promise.resolve(new KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder());\n            }\n        }\n    }\n    /**\n     * Constructor\n     * @param engine The engine to use\n     * @param numWorkersOrOptions The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n     */\n    constructor(engine, numWorkersOrOptions = KhronosTextureContainer2.DefaultNumWorkers) {\n        this._engine = engine;\n        const workerPoolOption = (typeof numWorkersOrOptions === \"object\" && numWorkersOrOptions.workerPool) || KhronosTextureContainer2.WorkerPool;\n        if (workerPoolOption) {\n            KhronosTextureContainer2._WorkerPoolPromise = Promise.resolve(workerPoolOption);\n        }\n        else {\n            // set the KTX2 decoder module\n            if (typeof numWorkersOrOptions === \"object\") {\n                KhronosTextureContainer2._KTX2DecoderModule = numWorkersOrOptions?.binariesAndModulesContainer?.jsDecoderModule;\n            }\n            else if (typeof KTX2DECODER !== \"undefined\") {\n                KhronosTextureContainer2._KTX2DecoderModule = KTX2DECODER;\n            }\n            const numberOfWorkers = typeof numWorkersOrOptions === \"number\" ? numWorkersOrOptions : (numWorkersOrOptions.numWorkers ?? KhronosTextureContainer2.DefaultNumWorkers);\n            KhronosTextureContainer2._Initialize(numberOfWorkers);\n        }\n    }\n    /**\n     * @internal\n     */\n    _uploadAsync(data, internalTexture, options) {\n        const caps = this._engine.getCaps();\n        const compressedTexturesCaps = {\n            astc: !!caps.astc,\n            bptc: !!caps.bptc,\n            s3tc: !!caps.s3tc,\n            pvrtc: !!caps.pvrtc,\n            etc2: !!caps.etc2,\n            etc1: !!caps.etc1,\n        };\n        if (KhronosTextureContainer2._WorkerPoolPromise) {\n            return KhronosTextureContainer2._WorkerPoolPromise.then((workerPool) => {\n                return new Promise((resolve, reject) => {\n                    workerPool.push((worker, onComplete) => {\n                        const onError = (error) => {\n                            worker.removeEventListener(\"error\", onError);\n                            worker.removeEventListener(\"message\", onMessage);\n                            reject(error);\n                            onComplete();\n                        };\n                        const onMessage = (message) => {\n                            if (message.data.action === \"decoded\") {\n                                worker.removeEventListener(\"error\", onError);\n                                worker.removeEventListener(\"message\", onMessage);\n                                if (!message.data.success) {\n                                    reject({ message: message.data.msg });\n                                }\n                                else {\n                                    try {\n                                        this._createTexture(message.data.decodedData, internalTexture, options);\n                                        resolve();\n                                    }\n                                    catch (err) {\n                                        reject({ message: err });\n                                    }\n                                }\n                                onComplete();\n                            }\n                        };\n                        worker.addEventListener(\"error\", onError);\n                        worker.addEventListener(\"message\", onMessage);\n                        worker.postMessage({ action: \"setDefaultDecoderOptions\", options: KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions() });\n                        const dataCopy = new Uint8Array(data.byteLength);\n                        dataCopy.set(new Uint8Array(data.buffer, data.byteOffset, data.byteLength));\n                        worker.postMessage({ action: \"decode\", data: dataCopy, caps: compressedTexturesCaps, options }, [dataCopy.buffer]);\n                    });\n                });\n            });\n        }\n        else if (KhronosTextureContainer2._DecoderModulePromise) {\n            return KhronosTextureContainer2._DecoderModulePromise.then((decoder) => {\n                if (KhronosTextureContainer2.DefaultDecoderOptions.isDirty) {\n                    KhronosTextureContainer2._KTX2DecoderModule.KTX2Decoder.DefaultDecoderOptions = KhronosTextureContainer2.DefaultDecoderOptions._getKTX2DecoderOptions();\n                }\n                return new Promise((resolve, reject) => {\n                    decoder\n                        .decode(data, caps)\n                        .then((data) => {\n                        this._createTexture(data, internalTexture);\n                        resolve();\n                    })\n                        .catch((reason) => {\n                        reject({ message: reason });\n                    });\n                });\n            });\n        }\n        throw new Error(\"KTX2 decoder module is not available\");\n    }\n    _createTexture(data, internalTexture, options) {\n        const oglTexture2D = 3553; // gl.TEXTURE_2D\n        this._engine._bindTextureDirectly(oglTexture2D, internalTexture);\n        if (options) {\n            // return back some information about the decoded data\n            options.transcodedFormat = data.transcodedFormat;\n            options.isInGammaSpace = data.isInGammaSpace;\n            options.hasAlpha = data.hasAlpha;\n            options.transcoderName = data.transcoderName;\n        }\n        let isUncompressedFormat = true;\n        switch (data.transcodedFormat) {\n            case 0x8058 /* RGBA8 */:\n                internalTexture.type = 0;\n                internalTexture.format = 5;\n                break;\n            case 0x8229 /* R8 */:\n                internalTexture.type = 0;\n                internalTexture.format = 6;\n                break;\n            case 0x822b /* RG8 */:\n                internalTexture.type = 0;\n                internalTexture.format = 7;\n                break;\n            default:\n                internalTexture.format = data.transcodedFormat;\n                isUncompressedFormat = false;\n                break;\n        }\n        internalTexture._gammaSpace = data.isInGammaSpace;\n        internalTexture.generateMipMaps = data.mipmaps.length > 1;\n        if (data.errors) {\n            throw new Error(\"KTX2 container - could not transcode the data. \" + data.errors);\n        }\n        for (let t = 0; t < data.mipmaps.length; ++t) {\n            const mipmap = data.mipmaps[t];\n            if (!mipmap || !mipmap.data) {\n                throw new Error(\"KTX2 container - could not transcode one of the image\");\n            }\n            if (isUncompressedFormat) {\n                // uncompressed RGBA / R8 / RG8\n                internalTexture.width = mipmap.width; // need to set width/height so that the call to _uploadDataToTextureDirectly uses the right dimensions\n                internalTexture.height = mipmap.height;\n                this._engine._uploadDataToTextureDirectly(internalTexture, mipmap.data, 0, t, undefined, true);\n            }\n            else {\n                this._engine._uploadCompressedDataToTextureDirectly(internalTexture, data.transcodedFormat, mipmap.width, mipmap.height, mipmap.data, 0, t);\n            }\n        }\n        internalTexture._extension = \".ktx2\";\n        internalTexture.width = data.mipmaps[0].width;\n        internalTexture.height = data.mipmaps[0].height;\n        internalTexture.isReady = true;\n        this._engine._bindTextureDirectly(oglTexture2D, null);\n    }\n    /**\n     * Checks if the given data starts with a KTX2 file identifier.\n     * @param data the data to check\n     * @returns true if the data is a KTX2 file or false otherwise\n     */\n    static IsValid(data) {\n        if (data.byteLength >= 12) {\n            // '«', 'K', 'T', 'X', ' ', '2', '0', '»', '\\r', '\\n', '\\x1A', '\\n'\n            const identifier = new Uint8Array(data.buffer, data.byteOffset, 12);\n            if (identifier[0] === 0xab &&\n                identifier[1] === 0x4b &&\n                identifier[2] === 0x54 &&\n                identifier[3] === 0x58 &&\n                identifier[4] === 0x20 &&\n                identifier[5] === 0x32 &&\n                identifier[6] === 0x30 &&\n                identifier[7] === 0xbb &&\n                identifier[8] === 0x0d &&\n                identifier[9] === 0x0a &&\n                identifier[10] === 0x1a &&\n                identifier[11] === 0x0a) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n/**\n * URLs to use when loading the KTX2 decoder module as well as its dependencies\n * If a url is null, the default url is used (pointing to https://preview.babylonjs.com)\n * Note that jsDecoderModule can't be null and that the other dependencies will only be loaded if necessary\n * Urls you can change:\n *     URLConfig.jsDecoderModule\n *     URLConfig.wasmUASTCToASTC\n *     URLConfig.wasmUASTCToBC7\n *     URLConfig.wasmUASTCToRGBA_UNORM\n *     URLConfig.wasmUASTCToRGBA_SRGB\n *     URLConfig.wasmUASTCToR8_UNORM\n *     URLConfig.wasmUASTCToRG8_UNORM\n *     URLConfig.jsMSCTranscoder\n *     URLConfig.wasmMSCTranscoder\n *     URLConfig.wasmZSTDDecoder\n * You can see their default values in this PG: https://playground.babylonjs.com/#EIJH8L#29\n */\nKhronosTextureContainer2.URLConfig = {\n    jsDecoderModule: \"https://cdn.babylonjs.com/babylon.ktx2Decoder.js\",\n    wasmUASTCToASTC: null,\n    wasmUASTCToBC7: null,\n    wasmUASTCToRGBA_UNORM: null,\n    wasmUASTCToRGBA_SRGB: null,\n    wasmUASTCToR8_UNORM: null,\n    wasmUASTCToRG8_UNORM: null,\n    jsMSCTranscoder: null,\n    wasmMSCTranscoder: null,\n    wasmZSTDDecoder: null,\n};\n/**\n * Default number of workers used to handle data decoding\n */\nKhronosTextureContainer2.DefaultNumWorkers = KhronosTextureContainer2.GetDefaultNumWorkers();\n/**\n * Default configuration for the KTX2 decoder.\n * The options defined in this way have priority over those passed when creating a KTX2 texture with new Texture(...).\n */\nKhronosTextureContainer2.DefaultDecoderOptions = new DefaultKTX2DecoderOptions();\n//# sourceMappingURL=khronosTextureContainer2.js.map","import { KhronosTextureContainer } from \"../../../Misc/khronosTextureContainer.js\";\nimport { KhronosTextureContainer2 } from \"../../../Misc/khronosTextureContainer2.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n\nfunction mapSRGBToLinear(format) {\n    switch (format) {\n        case 35916:\n            return 33776;\n        case 35918:\n            return 33778;\n        case 35919:\n            return 33779;\n        case 37493:\n            return 37492;\n        case 37497:\n            return 37496;\n        case 37495:\n            return 37494;\n        case 37840:\n            return 37808;\n        case 36493:\n            return 36492;\n    }\n    return null;\n}\n/**\n * Implementation of the KTX Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _KTXTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n        texture._invertVScale = !texture.invertY;\n        const engine = texture.getEngine();\n        const ktx = new KhronosTextureContainer(data, 6);\n        const loadMipmap = ktx.numberOfMipmapLevels > 1 && texture.generateMipMaps;\n        engine._unpackFlipY(true);\n        ktx.uploadLevels(texture, texture.generateMipMaps);\n        texture.width = ktx.pixelWidth;\n        texture.height = ktx.pixelHeight;\n        engine._setCubeMapTextureParams(texture, loadMipmap, ktx.numberOfMipmapLevels - 1);\n        texture.isReady = true;\n        texture.onLoadedObservable.notifyObservers(texture);\n        texture.onLoadedObservable.clear();\n        if (onLoad) {\n            onLoad();\n        }\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     * @param options\n     */\n    loadData(data, texture, callback, options) {\n        if (KhronosTextureContainer.IsValid(data)) {\n            // Need to invert vScale as invertY via UNPACK_FLIP_Y_WEBGL is not supported by compressed texture\n            texture._invertVScale = !texture.invertY;\n            const ktx = new KhronosTextureContainer(data, 1);\n            const mappedFormat = mapSRGBToLinear(ktx.glInternalFormat);\n            if (mappedFormat) {\n                texture.format = mappedFormat;\n                texture._useSRGBBuffer = texture.getEngine()._getUseSRGBBuffer(true, texture.generateMipMaps);\n                texture._gammaSpace = true;\n            }\n            else {\n                texture.format = ktx.glInternalFormat;\n            }\n            callback(ktx.pixelWidth, ktx.pixelHeight, texture.generateMipMaps, true, () => {\n                ktx.uploadLevels(texture, texture.generateMipMaps);\n            }, ktx.isInvalid);\n        }\n        else if (KhronosTextureContainer2.IsValid(data)) {\n            const ktx2 = new KhronosTextureContainer2(texture.getEngine());\n            ktx2._uploadAsync(data, texture, options).then(() => {\n                callback(texture.width, texture.height, texture.generateMipMaps, true, () => { }, false);\n            }, (error) => {\n                Logger.Warn(`Failed to load KTX2 texture data: ${error.message}`);\n                callback(0, 0, false, false, () => { }, true);\n            });\n        }\n        else {\n            Logger.Error(\"texture missing KTX identifier\");\n            callback(0, 0, false, false, () => { }, true);\n        }\n    }\n}\n//# sourceMappingURL=ktxTextureLoader.js.map"],"names":["KhronosTextureContainer","constructor","data","facesExpected","this","isInvalid","IsValid","dataSize","Uint32Array","BYTES_PER_ELEMENT","headerDataView","DataView","buffer","byteOffset","endianness","getUint32","littleEndian","glType","glTypeSize","glFormat","glInternalFormat","glBaseInternalFormat","pixelWidth","pixelHeight","pixelDepth","numberOfArrayElements","numberOfFaces","numberOfMipmapLevels","bytesOfKeyValueData","Math","max","loadType","COMPRESSED_2D","uploadLevels","texture","loadMipmaps","_upload2DCompressedLevels","TEX_2D","COMPRESSED_3D","TEX_3D","dataOffset","HEADER_LEN","width","height","mipmapCount","level","imageSize","Int32Array","face","byteArray","Uint8Array","engine","getEngine","_uploadCompressedDataToTextureDirectly","format","static","byteLength","identifier","WorkerPool","workers","_pendingActions","Array","_workerInfos","map","worker","workerPromise","Promise","resolve","idle","dispose","workerInfo","then","terminate","length","push","action","_executeOnIdleWorker","_execute","nextAction","shift","AutoReleaseWorkerPool","maxWorkers","createWorkerAsync","options","DefaultOptions","super","_maxWorkers","_createWorkerAsync","_options","timeoutId","clearTimeout","onComplete","setTimeout","indexOf","splice","idleTimeElapsedBeforeRelease","SourceTextureFormat","TranscodeTarget","EngineFormat","applyConfig","urls","binariesAndModulesContainer","KTX2DecoderModule","jsDecoderModule","KTX2DECODER","wasmUASTCToASTC","LiteTranscoder_UASTC_ASTC","WasmModuleURL","wasmUASTCToBC7","LiteTranscoder_UASTC_BC7","wasmUASTCToRGBA_UNORM","LiteTranscoder_UASTC_RGBA_UNORM","wasmUASTCToRGBA_SRGB","LiteTranscoder_UASTC_RGBA_SRGB","wasmUASTCToR8_UNORM","LiteTranscoder_UASTC_R8_UNORM","wasmUASTCToRG8_UNORM","LiteTranscoder_UASTC_RG8_UNORM","jsMSCTranscoder","MSCTranscoder","JSModuleURL","wasmMSCTranscoder","wasmZSTDDecoder","ZSTDDecoder","WasmBinary","JSModule","workerFunction","ktx2Decoder","onmessage","event","importScripts","wasmBinaries","undefined","KTX2Decoder","postMessage","DefaultDecoderOptions","decode","caps","buffers","mip","mipmaps","mipmap","success","decodedData","catch","reason","msg","initializeWebWorker","reject","onError","error","removeEventListener","onMessage","message","addEventListener","DefaultKTX2DecoderOptions","_isDirty","_useRGBAIfOnlyBC1BC3AvailableWhenUASTC","_ktx2DecoderOptions","isDirty","useRGBAIfASTCBC7NotAvailableWhenUASTC","_useRGBAIfASTCBC7NotAvailableWhenUASTC","value","useRGBAIfOnlyBC1BC3AvailableWhenUASTC","forceRGBA","_forceRGBA","forceR8","_forceR8","forceRG8","_forceRG8","bypassTranscoders","_bypassTranscoders","_getKTX2DecoderOptions","transcodeFormatDecisionTree","UASTC","transcodeFormat","BC1_RGB","BC3_RGBA","yes","RGBA32","engineFormat","roundToMultiple4","KhronosTextureContainer2","navigator","hardwareConcurrency","min","floor","numWorkers","_WorkerPoolPromise","_DecoderModulePromise","URLConfig","Worker","URL","workerContent","workerBlobUrl","createObjectURL","Blob","type","_KTX2DecoderModule","UseFromWorkerThread","WASMMemoryManager","LoadBinariesFromCurrentThread","numWorkersOrOptions","DefaultNumWorkers","_engine","workerPoolOption","workerPool","numberOfWorkers","_Initialize","_uploadAsync","internalTexture","getCaps","compressedTexturesCaps","astc","bptc","s3tc","pvrtc","etc2","etc1","_createTexture","err","dataCopy","set","decoder","Error","oglTexture2D","_bindTextureDirectly","transcodedFormat","isInGammaSpace","hasAlpha","transcoderName","isUncompressedFormat","_gammaSpace","generateMipMaps","errors","t","_uploadDataToTextureDirectly","_extension","isReady","mapSRGBToLinear","GetDefaultNumWorkers","_KTXTextureLoader","supportCascades","loadCubeData","createPolynomials","onLoad","isArray","_invertVScale","invertY","ktx","loadMipmap","_unpackFlipY","_setCubeMapTextureParams","onLoadedObservable","notifyObservers","clear","loadData","callback","mappedFormat","_useSRGBBuffer","_getUseSRGBBuffer","ktx2"],"sourceRoot":""}