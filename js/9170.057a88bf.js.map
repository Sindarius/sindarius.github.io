{"version":3,"file":"js/9170.057a88bf.js","mappings":"gJAEA,MAAMA,EAAO,+BACPC,EAAS,iCAEf,6BAAqCD,GAAQC,C,+GCH7C,MAAM,EAAO,mBACPA,EAAS,qYAKf,6BAAqC,GAAQA,EAEtC,MCRD,EAAO,qBACP,EAAS,wbAaf,6BAAqC,GAAQ,EAEtC,MChBD,EAAO,sBACP,EAAS,miBAYf,6BAAqC,GAAQ,EAEtC,MCXD,EAAO,wBACP,EAAS,mvCAqCf,qBAA6B,GAAQ,EAE9B,MAAMC,EAA4B,CAAEF,KAAI,SAAQ,E","sources":["webpack://gcodeviewer_site/./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurVaryingDeclaration.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/packingFunctions.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/ShadersWGSL/ShadersInclude/kernelBlurFragment2.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/ShadersWGSL/kernelBlur.fragment.js"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurVaryingDeclaration\";\nconst shader = `varying sampleCoord{X}: vec2f;`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const kernelBlurVaryingDeclarationWGSL = { name, shader };\n//# sourceMappingURL=kernelBlurVaryingDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"packingFunctions\";\nconst shader = `fn pack(depth: f32)->vec4f\n{const bit_shift: vec4f= vec4f(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const bit_mask: vec4f= vec4f(0.0,1.0/255.0,1.0/255.0,1.0/255.0);var res: vec4f=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\nfn unpack(color: vec4f)->f32\n{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const packingFunctionsWGSL = { name, shader };\n//# sourceMappingURL=packingFunctions.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurFragment\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(fragmentInputs.sampleCoord{X}); \ncomputedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X}))*computedWeight;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X})*computedWeight;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const kernelBlurFragmentWGSL = { name, shader };\n//# sourceMappingURL=kernelBlurFragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"kernelBlurFragment2\";\nconst shader = `#ifdef DOF\nfactor=sampleCoC(fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const kernelBlurFragment2WGSL = { name, shader };\n//# sourceMappingURL=kernelBlurFragment2.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/kernelBlurVaryingDeclaration.js\";\nimport \"./ShadersInclude/packingFunctions.js\";\nimport \"./ShadersInclude/kernelBlurFragment.js\";\nimport \"./ShadersInclude/kernelBlurFragment2.js\";\nconst name = \"kernelBlurPixelShader\";\nconst shader = `var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform delta: vec2f;varying sampleCenter: vec2f;\n#ifdef DOF\nvar circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;fn sampleCoC(offset: vec2f)->f32 {var coc: f32=textureSample(circleOfConfusionSampler,circleOfConfusionSamplerSampler,offset).r;return coc; }\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {var computedWeight: f32=0.0;\n#ifdef PACKEDFLOAT\nvar blend: f32=0.;\n#else\nvar blend: vec4f= vec4f(0.);\n#endif\n#ifdef DOF\nvar sumOfWeights: f32=CENTER_WEIGHT; \nvar factor: f32=0.0;\n#ifdef PACKEDFLOAT\nblend+=unpack(textureSample(textureSampler,textureSamplerSampler,input.sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=textureSample(textureSampler,textureSamplerSampler,input.sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\nfragmentOutputs.color=pack(blend);\n#else\nfragmentOutputs.color=blend;\n#endif\n#ifdef DOF\nfragmentOutputs.color/=sumOfWeights;\n#endif\n}`;\n// Sideeffect\nShaderStore.ShadersStoreWGSL[name] = shader;\n/** @internal */\nexport const kernelBlurPixelShaderWGSL = { name, shader };\n//# sourceMappingURL=kernelBlur.fragment.js.map"],"names":["name","shader","kernelBlurPixelShaderWGSL"],"sourceRoot":""}