{"version":3,"file":"js/537.1c5a2099.js","mappings":"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","sources":["webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Misc/environmentTextureTools.js","webpack://gcodeviewer_site/./node_modules/@babylonjs/core/Materials/Textures/Loaders/envTextureLoader.js"],"sourcesContent":["import { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nBaseTexture.prototype.forceSphericalPolynomialsRecompute = function () {\n    if (this._texture) {\n        this._texture._sphericalPolynomial = null;\n        this._texture._sphericalPolynomialPromise = null;\n        this._texture._sphericalPolynomialComputed = false;\n    }\n};\nObject.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\n    get: function () {\n        if (this._texture) {\n            if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {\n                return this._texture._sphericalPolynomial;\n            }\n            if (this._texture.isReady) {\n                if (!this._texture._sphericalPolynomialPromise) {\n                    this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\n                    if (this._texture._sphericalPolynomialPromise === null) {\n                        this._texture._sphericalPolynomialComputed = true;\n                    }\n                    else {\n                        this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {\n                            this._texture._sphericalPolynomial = sphericalPolynomial;\n                            this._texture._sphericalPolynomialComputed = true;\n                        });\n                    }\n                }\n                return null;\n            }\n        }\n        return null;\n    },\n    set: function (value) {\n        if (this._texture) {\n            this._texture._sphericalPolynomial = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\n//# sourceMappingURL=baseTexture.polynomial.js.map","import { Tools } from \"./tools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { ILog2 } from \"../Maths/math.scalar.functions.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture } from \"../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\n\nimport { Scene } from \"../scene.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport \"../Materials/Textures/baseTexture.polynomial.js\";\nimport { DumpDataAsync } from \"../Misc/dumpTools.js\";\nconst DefaultEnvironmentTextureImageType = \"image/png\";\nconst CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\nexport function GetEnvInfo(data) {\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    let pos = 0;\n    for (let i = 0; i < MagicBytes.length; i++) {\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n            Logger.Error(\"Not a babylon environment map\");\n            return null;\n        }\n    }\n    // Read json manifest - collect characters up to null terminator\n    let manifestString = \"\";\n    let charCode = 0x00;\n    while ((charCode = dataView.getUint8(pos++))) {\n        manifestString += String.fromCharCode(charCode);\n    }\n    let manifest = JSON.parse(manifestString);\n    manifest = normalizeEnvInfo(manifest);\n    if (manifest.specular) {\n        // Extend the header with the position of the payload.\n        manifest.specular.specularDataPosition = pos;\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n    }\n    return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\nexport function normalizeEnvInfo(info) {\n    if (info.version > CurrentVersion) {\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\n    }\n    if (info.version === 2) {\n        return info;\n    }\n    // Migrate a v1 info to v2\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\n    return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n * @param options.imageQuality the image quality of encoded WebP images.\n * @returns a promise containing the environment data if successful.\n */\nexport async function CreateEnvTextureAsync(texture, options = {}) {\n    const internalTexture = texture.getInternalTexture();\n    if (!internalTexture) {\n        return Promise.reject(\"The cube texture is invalid.\");\n    }\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\n    const engine = internalTexture.getEngine();\n    if (texture.textureType !== 2 &&\n        texture.textureType !== 1 &&\n        texture.textureType !== 0 &&\n        texture.textureType !== 0 &&\n        texture.textureType !== 7 &&\n        texture.textureType !== -1) {\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n    }\n    let textureType = 1;\n    if (!engine.getCaps().textureFloatRender) {\n        textureType = 2;\n        if (!engine.getCaps().textureHalfFloatRender) {\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n        }\n    }\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\n    texture.sphericalPolynomial;\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\n    const cubeWidth = internalTexture.width;\n    const hostingScene = new Scene(engine);\n    const specularTextures = {};\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n    engine.flushFramebuffer();\n    // Read and collect all mipmaps data from the cube.\n    const mipmapsCount = ILog2(internalTexture.width);\n    for (let i = 0; i <= mipmapsCount; i++) {\n        const faceWidth = Math.pow(2, mipmapsCount - i);\n        // All faces of the cube.\n        for (let face = 0; face < 6; face++) {\n            let faceData = await texture.readPixels(face, i, undefined, false);\n            if (faceData && faceData.byteLength === faceData.length) {\n                const faceDataFloat = new Float32Array(faceData.byteLength * 4);\n                for (let i = 0; i < faceData.byteLength; i++) {\n                    faceDataFloat[i] = faceData[i] / 255;\n                    // Gamma to linear\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\n                }\n                faceData = faceDataFloat;\n            }\n            else if (faceData && texture.gammaSpace) {\n                const floatData = faceData;\n                for (let i = 0; i < floatData.length; i++) {\n                    // Gamma to linear\n                    floatData[i] = Math.pow(floatData[i], 2.2);\n                }\n            }\n            const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\n            const imageEncodedData = await DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\n            specularTextures[i * 6 + face] = imageEncodedData;\n            tempTexture.dispose();\n        }\n    }\n    // We can delete the hosting scene keeping track of all the creation objects\n    hostingScene.dispose();\n    // Ensure completion of the polynomial creation promise.\n    if (sphericalPolynomialPromise) {\n        await sphericalPolynomialPromise;\n    }\n    // Creates the json header for the env texture\n    const info = {\n        version: CurrentVersion,\n        width: cubeWidth,\n        imageType,\n        irradiance: _CreateEnvTextureIrradiance(texture),\n        specular: {\n            mipmaps: [],\n            lodGenerationScale: texture.lodGenerationScale,\n        },\n    };\n    // Sets the specular image data information\n    let position = 0;\n    for (let i = 0; i <= mipmapsCount; i++) {\n        for (let face = 0; face < 6; face++) {\n            const byteLength = specularTextures[i * 6 + face].byteLength;\n            info.specular.mipmaps.push({\n                length: byteLength,\n                position: position,\n            });\n            position += byteLength;\n        }\n    }\n    // Encode the JSON as an array buffer\n    const infoString = JSON.stringify(info);\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\n        infoView[i] = infoString.charCodeAt(i);\n    }\n    // Ends up with a null terminator for easier parsing\n    infoView[infoString.length] = 0x00;\n    // Computes the final required size and creates the storage\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n    const finalBuffer = new ArrayBuffer(totalSize);\n    const finalBufferView = new Uint8Array(finalBuffer);\n    const dataView = new DataView(finalBuffer);\n    // Copy the magic bytes identifying the file in\n    let pos = 0;\n    for (let i = 0; i < MagicBytes.length; i++) {\n        dataView.setUint8(pos++, MagicBytes[i]);\n    }\n    // Add the json info\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\n    pos += infoBuffer.byteLength;\n    // Finally inserts the texture data\n    for (let i = 0; i <= mipmapsCount; i++) {\n        for (let face = 0; face < 6; face++) {\n            const dataBuffer = specularTextures[i * 6 + face];\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\n            pos += dataBuffer.byteLength;\n        }\n    }\n    // Voila\n    return finalBuffer;\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @returns the JSON representation of the spherical info\n */\nfunction _CreateEnvTextureIrradiance(texture) {\n    const polynmials = texture.sphericalPolynomial;\n    if (polynmials == null) {\n        return null;\n    }\n    return {\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\n    };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateImageDataArrayBufferViews(data, info) {\n    info = normalizeEnvInfo(info);\n    const specularInfo = info.specular;\n    // Double checks the enclosed info\n    let mipmapsCount = Math.log2(info.width);\n    mipmapsCount = Math.round(mipmapsCount) + 1;\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\n    }\n    const imageData = new Array(mipmapsCount);\n    for (let i = 0; i < mipmapsCount; i++) {\n        imageData[i] = new Array(6);\n        for (let face = 0; face < 6; face++) {\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n        }\n    }\n    return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\nexport function UploadEnvLevelsAsync(texture, data, info) {\n    info = normalizeEnvInfo(info);\n    const specularInfo = info.specular;\n    if (!specularInfo) {\n        // Nothing else parsed so far\n        return Promise.resolve();\n    }\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\n    const imageData = CreateImageDataArrayBufferViews(data, info);\n    return UploadLevelsAsync(texture, imageData, info.imageType);\n}\nfunction _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n    return new Promise((resolve, reject) => {\n        if (expandTexture) {\n            const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message) => {\n                reject(message);\n            }, image);\n            rgbdPostProcess?.onEffectCreatedObservable.addOnce((effect) => {\n                effect.executeWhenCompiled(() => {\n                    // Uncompress the data to a RTT\n                    rgbdPostProcess.externalTextureSamplerBinding = true;\n                    rgbdPostProcess.onApply = (effect) => {\n                        effect._bindTexture(\"textureSampler\", tempTexture);\n                        effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n                    };\n                    if (!engine.scenes.length) {\n                        return;\n                    }\n                    engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\n                    // Cleanup\n                    engine.restoreDefaultFramebuffer();\n                    tempTexture.dispose();\n                    URL.revokeObjectURL(url);\n                    resolve();\n                });\n            });\n        }\n        else {\n            engine._uploadImageToTexture(texture, image, face, i);\n            // Upload the face to the non lod texture support\n            if (generateNonLODTextures) {\n                const lodTexture = lodTextures[i];\n                if (lodTexture) {\n                    engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n                }\n            }\n            resolve();\n        }\n    });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nexport async function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {\n    if (!Tools.IsExponentOfTwo(texture.width)) {\n        throw new Error(\"Texture size must be a power of two\");\n    }\n    const mipmapsCount = ILog2(texture.width) + 1;\n    // Gets everything ready.\n    const engine = texture.getEngine();\n    let expandTexture = false;\n    let generateNonLODTextures = false;\n    let rgbdPostProcess = null;\n    let cubeRtt = null;\n    let lodTextures = null;\n    const caps = engine.getCaps();\n    texture.format = 5;\n    texture.type = 0;\n    texture.generateMipMaps = true;\n    texture._cachedAnisotropicFilteringLevel = null;\n    engine.updateTextureSamplingMode(3, texture);\n    // Add extra process if texture lod is not supported\n    if (!caps.textureLOD) {\n        expandTexture = false;\n        generateNonLODTextures = true;\n        lodTextures = {};\n    }\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n        expandTexture = false;\n    }\n    // If half float available we can uncompress the texture\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n        expandTexture = true;\n        texture.type = 2;\n    }\n    // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n        expandTexture = true;\n        texture.type = 1;\n    }\n    // Expand the texture if possible\n    let shaderLanguage = 0 /* ShaderLanguage.GLSL */;\n    if (expandTexture) {\n        if (engine.isWebGPU) {\n            shaderLanguage = 1 /* ShaderLanguage.WGSL */;\n            await import(\"../ShadersWGSL/rgbdDecode.fragment.js\");\n        }\n        else {\n            await import(\"../Shaders/rgbdDecode.fragment.js\");\n        }\n        // Simply run through the decode PP\n        rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false, undefined, shaderLanguage);\n        texture._isRGBD = false;\n        texture.invertY = false;\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n            generateDepthBuffer: false,\n            generateMipMaps: true,\n            generateStencilBuffer: false,\n            samplingMode: 3,\n            type: texture.type,\n            format: 5,\n        });\n    }\n    else {\n        texture._isRGBD = true;\n        texture.invertY = true;\n        // In case of missing support, applies the same patch than DDS files.\n        if (generateNonLODTextures) {\n            const mipSlices = 3;\n            const scale = texture._lodGenerationScale;\n            const offset = texture._lodGenerationOffset;\n            for (let i = 0; i < mipSlices; i++) {\n                //compute LOD from even spacing in smoothness (matching shader calculation)\n                const smoothness = i / (mipSlices - 1);\n                const roughness = 1 - smoothness;\n                const minLODIndex = offset; // roughness = 0\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n                const glTextureFromLod = new InternalTexture(engine, 2 /* InternalTextureSource.Temp */);\n                glTextureFromLod.isCube = true;\n                glTextureFromLod.invertY = true;\n                glTextureFromLod.generateMipMaps = false;\n                engine.updateTextureSamplingMode(2, glTextureFromLod);\n                // Wrap in a base texture for easy binding.\n                const lodTexture = new BaseTexture(null);\n                lodTexture._isCube = true;\n                lodTexture._texture = glTextureFromLod;\n                lodTextures[mipmapIndex] = lodTexture;\n                switch (i) {\n                    case 0:\n                        texture._lodTextureLow = lodTexture;\n                        break;\n                    case 1:\n                        texture._lodTextureMid = lodTexture;\n                        break;\n                    case 2:\n                        texture._lodTextureHigh = lodTexture;\n                        break;\n                }\n            }\n        }\n    }\n    const promises = [];\n    // All mipmaps up to provided number of images\n    for (let i = 0; i < imageData.length; i++) {\n        // All faces\n        for (let face = 0; face < 6; face++) {\n            // Constructs an image element from image data\n            const bytes = imageData[i][face];\n            const blob = new Blob([bytes], { type: imageType });\n            const url = URL.createObjectURL(blob);\n            let promise;\n            if (engine._features.forceBitmapOverHTMLImageElement) {\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n                });\n            }\n            else {\n                const image = new Image();\n                image.src = url;\n                // Enqueue promise to upload to the texture.\n                promise = new Promise((resolve, reject) => {\n                    image.onload = () => {\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\n                            .then(() => resolve())\n                            .catch((reason) => {\n                            reject(reason);\n                        });\n                    };\n                    image.onerror = (error) => {\n                        reject(error);\n                    };\n                });\n            }\n            promises.push(promise);\n        }\n    }\n    // Fill remaining mipmaps with black textures.\n    if (imageData.length < mipmapsCount) {\n        let data;\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n        const dataLength = size * size * 4;\n        switch (texture.type) {\n            case 0: {\n                data = new Uint8Array(dataLength);\n                break;\n            }\n            case 2: {\n                data = new Uint16Array(dataLength);\n                break;\n            }\n            case 1: {\n                data = new Float32Array(dataLength);\n                break;\n            }\n        }\n        for (let i = imageData.length; i < mipmapsCount; i++) {\n            for (let face = 0; face < 6; face++) {\n                engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n            }\n        }\n    }\n    // Once all done, finishes the cleanup and return\n    return Promise.all(promises).then(() => {\n        // Release temp RTT.\n        if (cubeRtt) {\n            engine._releaseTexture(texture);\n            cubeRtt._swapAndDie(texture);\n        }\n        // Release temp Post Process.\n        if (rgbdPostProcess) {\n            rgbdPostProcess.dispose();\n        }\n        // Flag internal texture as ready in case they are in use.\n        if (generateNonLODTextures) {\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n                texture._lodTextureHigh._texture.isReady = true;\n            }\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n                texture._lodTextureMid._texture.isReady = true;\n            }\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n                texture._lodTextureLow._texture.isReady = true;\n            }\n        }\n    });\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\nexport function UploadEnvSpherical(texture, info) {\n    info = normalizeEnvInfo(info);\n    const irradianceInfo = info.irradiance;\n    if (!irradianceInfo) {\n        return;\n    }\n    const sp = new SphericalPolynomial();\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n    texture._sphericalPolynomial = sp;\n}\n/**\n * @internal\n */\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n    const proxy = internalTexture\n        .getEngine()\n        .createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\n    internalTexture.onRebuildCallback = (_internalTexture) => {\n        return {\n            proxy: proxyPromise,\n            isReady: true,\n            isAsync: true,\n        };\n    };\n    internalTexture._source = 13 /* InternalTextureSource.CubeRawRGBD */;\n    internalTexture._bufferViewArrayArray = data;\n    internalTexture._lodGenerationScale = lodScale;\n    internalTexture._lodGenerationOffset = lodOffset;\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\n    return UploadLevelsAsync(internalTexture, data).then(() => {\n        internalTexture.isReady = true;\n        return internalTexture;\n    });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\nexport const EnvironmentTextureTools = {\n    /**\n     * Gets the environment info from an env file.\n     * @param data The array buffer containing the .env bytes.\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n     */\n    GetEnvInfo,\n    /**\n     * Creates an environment texture from a loaded cube texture.\n     * @param texture defines the cube texture to convert in env file\n     * @param options options for the conversion process\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n     * @param options.imageQuality the image quality of encoded WebP images.\n     * @returns a promise containing the environment data if successful.\n     */\n    CreateEnvTextureAsync,\n    /**\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\n     * @param data the image data\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\n     * @returns the views described by info providing access to the underlying buffer\n     */\n    CreateImageDataArrayBufferViews,\n    /**\n     * Uploads the texture info contained in the env file to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param data defines the data to load\n     * @param info defines the texture info retrieved through the GetEnvInfo method\n     * @returns a promise\n     */\n    UploadEnvLevelsAsync,\n    /**\n     * Uploads the levels of image data to the GPU.\n     * @param texture defines the internal texture to upload to\n     * @param imageData defines the array buffer views of image data [mipmap][face]\n     * @param imageType the mime type of the image data\n     * @returns a promise\n     */\n    UploadLevelsAsync,\n    /**\n     * Uploads spherical polynomials information to the texture.\n     * @param texture defines the texture we are trying to upload the information to\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\n     */\n    UploadEnvSpherical,\n};\n//# sourceMappingURL=environmentTextureTools.js.map","import { GetEnvInfo, UploadEnvLevelsAsync, UploadEnvSpherical } from \"../../../Misc/environmentTextureTools.js\";\n/**\n * Implementation of the ENV Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _ENVTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     * @param onError defines the callback to trigger in case of error\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad, onError) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        const info = GetEnvInfo(data);\n        if (info) {\n            texture.width = info.width;\n            texture.height = info.width;\n            try {\n                UploadEnvSpherical(texture, info);\n                UploadEnvLevelsAsync(texture, data, info).then(() => {\n                    texture.isReady = true;\n                    texture.onLoadedObservable.notifyObservers(texture);\n                    texture.onLoadedObservable.clear();\n                    if (onLoad) {\n                        onLoad();\n                    }\n                }, (reason) => {\n                    onError?.(\"Can not upload environment levels\", reason);\n                });\n            }\n            catch (e) {\n                onError?.(\"Can not upload environment file\", e);\n            }\n        }\n        else if (onError) {\n            onError(\"Can not parse the environment file\", null);\n        }\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     */\n    loadData() {\n        // eslint-disable-next-line no-throw-literal\n        throw \".env not supported in 2d.\";\n    }\n}\n//# sourceMappingURL=envTextureLoader.js.map"],"names":["this","_texture","_sphericalPolynomial","_sphericalPolynomialPromise","_sphericalPolynomialComputed","Object","defineProperty","get","isReady","then","sphericalPolynomial","set","value","enumerable","configurable","DefaultEnvironmentTextureImageType","CurrentVersion","MagicBytes","GetEnvInfo","data","dataView","DataView","buffer","byteOffset","byteLength","pos","i","length","getUint8","manifestString","charCode","String","fromCharCode","manifest","JSON","parse","normalizeEnvInfo","specular","specularDataPosition","lodGenerationScale","info","version","Error","imageType","CreateImageDataArrayBufferViews","specularInfo","mipmapsCount","Math","log2","width","round","mipmaps","imageData","Array","face","imageInfo","Uint8Array","position","UploadEnvLevelsAsync","texture","Promise","resolve","_lodGenerationScale","UploadLevelsAsync","_OnImageReadyAsync","image","engine","expandTexture","rgbdPostProcess","url","generateNonLODTextures","lodTextures","cubeRtt","reject","tempTexture","createTexture","message","onEffectCreatedObservable","addOnce","effect","executeWhenCompiled","externalTextureSamplerBinding","onApply","_bindTexture","setFloat2","_features","needsInvertingBitmap","ImageBitmap","scenes","postProcessManager","directRender","restoreDefaultFramebuffer","dispose","URL","revokeObjectURL","_uploadImageToTexture","lodTexture","async","getEngine","caps","getCaps","format","type","generateMipMaps","_cachedAnisotropicFilteringLevel","updateTextureSamplingMode","textureLOD","supportRenderAndCopyToLodForFloatTextures","textureHalfFloatRender","textureHalfFloatLinearFiltering","textureFloatRender","textureFloatLinearFiltering","shaderLanguage","isWebGPU","undefined","_isRGBD","invertY","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","samplingMode","mipSlices","scale","offset","_lodGenerationOffset","smoothness","roughness","minLODIndex","maxLODIndex","lodIndex","mipmapIndex","min","max","glTextureFromLod","isCube","_isCube","_lodTextureLow","_lodTextureMid","_lodTextureHigh","promises","bytes","blob","Blob","createObjectURL","promise","forceBitmapOverHTMLImageElement","createImageBitmap","premultiplyAlpha","img","Image","src","onload","catch","reason","onerror","error","push","size","pow","dataLength","Uint16Array","Float32Array","_uploadArrayBufferViewToTexture","all","_releaseTexture","_swapAndDie","UploadEnvSpherical","irradianceInfo","irradiance","sp","x","y","z","xx","yy","zz","yz","zx","xy","_ENVTextureLoader","constructor","supportCascades","loadCubeData","createPolynomials","onLoad","onError","isArray","height","onLoadedObservable","notifyObservers","clear","e","loadData"],"sourceRoot":""}